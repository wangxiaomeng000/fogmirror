import { BaseAIService } from './aiInterface';
import { AnalysisResult, EmotionalTone } from '../../types';

interface ExtractedFactsBackend {
  facts: string[];
  subjectiveStatements: string[];
  missingInformation: string[];
  keywords: string[];
}

export class FactualMockAIService extends BaseAIService {
  name = 'factual-mock';

  private initialGreeting = "我注意到你想要探讨一些问题。让我们从具体事实开始。请描述一个最近发生的具体事件——包括时间、地点、涉及的人，以及具体发生了什么。";

  private factExtractionQuestions = [
    "这件事具体发生在什么时候？能精确到哪一天吗？",
    "当时你在哪里？周围的环境是怎样的？",
    "除了你之外，还有谁在场？他们的身份是什么？",
    "你能描述一下具体发生了什么吗？谁说了什么，做了什么？",
    "这个事件持续了多长时间？",
    "有什么可以观察到的客观结果吗？",
    "你有任何文字记录、照片或其他证据吗？",
    "在这之前和之后，还发生了什么相关的事情？"
  ];

  private biasDetectionResponses = {
    generalization: "我注意到你使用了'总是'或'从不'这样的词。真的是每一次都这样吗？能举个反例吗？",
    assumption: "你提到的这个判断，是基于直接观察还是你的推测？",
    mind_reading: "你说对方'肯定认为'，你是如何知道他们的想法的？他们有直接表达过吗？",
    catastrophizing: "你描述的最坏情况，发生的概率有多大？还有其他可能的结果吗？",
    binary_thinking: "除了这两种极端情况，中间还有其他可能性吗？"
  };

  async analyzeMessage(content: string, imageBase64?: string, conversationHistory?: any[]) {
    await this.delay(800 + Math.random() * 800);

    let response: string;
    const extractedFacts = this.extractFacts(content);
    
    if (!conversationHistory || conversationHistory.length === 0) {
      response = this.initialGreeting;
    } else {
      // 分析内容，生成基于事实的回应
      response = await this.generateFactualResponse(content, extractedFacts, conversationHistory, !!imageBase64);
    }

    const analysis = await this.generateFactualAnalysis(content, extractedFacts, imageBase64);

    return { response, analysis };
  }

  private extractFacts(content: string): ExtractedFactsBackend {
    const facts: string[] = [];
    const subjectiveStatements: string[] = [];
    const missingInformation: string[] = [];
    const keywords: string[] = [];

    // 简化的事实提取逻辑
    const sentences = content.split(/[。！？,.!?]/).filter(s => s.trim());
    
    sentences.forEach(sentence => {
      // 检查时间信息
      const timePattern = /(\d{1,2}[年月日时分]|昨天|今天|明天|上周|本周|早上|晚上)/;
      const hasTime = timePattern.test(sentence);
      
      // 检查地点信息
      const locationPattern = /(公司|家里|学校|办公室|会议室|餐厅|路上)/;
      const hasLocation = locationPattern.test(sentence);
      
      // 检查人物信息
      const peoplePattern = /(我|他|她|同事|朋友|老板|父母|孩子)/;
      const hasPeople = peoplePattern.test(sentence);
      
      // 检查主观词汇
      const subjectiveWords = ['觉得', '认为', '可能', '应该', '一定', '肯定', '总是', '从不'];
      const isSubjective = subjectiveWords.some(word => sentence.includes(word));
      
      if (isSubjective) {
        subjectiveStatements.push(sentence);
      } else if (hasTime || hasLocation || hasPeople) {
        facts.push(sentence);
      }
      
      // 提取关键词
      const words = sentence.split(/\s+/);
      keywords.push(...words.filter(w => w.length > 3));
    });

    // 检查缺失信息
    if (!content.match(/(\d{1,2}[年月日时分]|昨天|今天|明天)/)) {
      missingInformation.push('具体时间');
    }
    if (!content.match(/(公司|家里|学校|办公室|会议室)/)) {
      missingInformation.push('具体地点');
    }
    if (!content.match(/[^我]的?(同事|朋友|老板|父母)/)) {
      missingInformation.push('相关人物身份');
    }

    return { facts, subjectiveStatements, missingInformation, keywords: [...new Set(keywords)] };
  }

  private async generateFactualResponse(
    content: string, 
    extractedFacts: ExtractedFactsBackend, 
    history: any[],
    hasImage: boolean
  ): Promise<string> {
    const responses: string[] = [];

    // 1. 确认理解到的事实
    if (extractedFacts.facts.length > 0) {
      responses.push(`我理解了这些具体信息：${extractedFacts.facts.slice(0, 2).join('；')}。`);
    }

    // 2. 指出主观判断
    if (extractedFacts.subjectiveStatements.length > 0) {
      const statement = extractedFacts.subjectiveStatements[0];
      responses.push(`你提到"${this.truncate(statement, 30)}"，这是基于什么具体观察？`);
    }

    // 3. 询问缺失信息
    if (extractedFacts.missingInformation.length > 0) {
      const missingInfo = extractedFacts.missingInformation[0];
      const questionIndex = Math.min(history.length, this.factExtractionQuestions.length - 1);
      responses.push(this.factExtractionQuestions[questionIndex]);
    }

    // 4. 检测认知偏见
    const bias = this.detectBias(content);
    if (bias) {
      responses.push(this.biasDetectionResponses[bias]);
    }

    // 5. 如果有图片，提示关注图片细节
    if (hasImage) {
      responses.push("我看到你上传了图片。图中有哪些具体的物体、人物或文字？请描述你观察到的客观细节。");
    }
    
    // 如果信息较完整，引导深入思考
    if (extractedFacts.facts.length >= 3 && extractedFacts.missingInformation.length === 0) {
      responses.push("根据这些事实，你认为问题的关键是什么？有什么是之前没有注意到的吗？");
    }

    return responses.join(' ');
  }

  private detectBias(content: string): keyof typeof this.biasDetectionResponses | null {
    if (/总是|从不|每次都|所有人/.test(content)) return 'generalization';
    if (/他肯定|她一定|他们必然/.test(content)) return 'mind_reading';
    if (/完蛋了|没救了|彻底完了/.test(content)) return 'catastrophizing';
    if (/要么.*要么|不是.*就是/.test(content)) return 'binary_thinking';
    if (/应该|必须|不得不/.test(content)) return 'assumption';
    return null;
  }

  private async generateFactualAnalysis(
    content: string, 
    extractedFacts: ExtractedFactsBackend,
    imageBase64?: string
  ): Promise<AnalysisResult> {
    // 构建事实层
    let facts = extractedFacts.facts.length > 0 
      ? [...extractedFacts.facts]
      : [`陈述中包含${extractedFacts.subjectiveStatements.length}个主观判断`];
      
    // 如果有图片，添加图片分析结果
    if (imageBase64) {
      const imageAnomalies = await this.analyzeImageForAbnormalities(imageBase64);
      facts.push(...imageAnomalies.slice(0, 2));
    }

    // 生成洞见层
    const insights: string[] = [];
    if (extractedFacts.subjectiveStatements.length > extractedFacts.facts.length) {
      insights.push('叙述以主观感受为主，缺少客观事实支撑');
    }
    if (extractedFacts.missingInformation.length > 0) {
      insights.push(`关键信息缺失：${extractedFacts.missingInformation.join('、')}`);
    }
    if (extractedFacts.facts.length >= 3) {
      insights.push('已提供基础事实框架，可以开始深入分析');
    }

    // 识别概念层
    const concepts: string[] = [];
    const bias = this.detectBias(content);
    if (bias) {
      concepts.push(`认知模式：${this.biasToConceptMap[bias]}`);
    }
    if (content.includes('应该') || content.includes('必须')) {
      concepts.push('规则导向的思维框架');
    }
    if (extractedFacts.keywords.some(k => ['完美', '失败', '成功'].includes(k))) {
      concepts.push('二元评价体系');
    }

    // 生成建议
    const suggestions = this.generateSuggestions(extractedFacts);

    return {
      facts,
      insights: insights.length > 0 ? insights : ['需要更多信息以形成洞见'],
      concepts: concepts.length > 0 ? concepts : ['认知框架待探索'],
      emotionalTone: {
        primary: '理性探索',
        intensity: 0.3,
        confidence: 0.8
      },
      suggestions
    };
  }

  private biasToConceptMap: Record<string, string> = {
    generalization: '过度概括倾向',
    assumption: '预设立场',
    mind_reading: '投射性思维',
    catastrophizing: '灾难化思维',
    binary_thinking: '非黑即白'
  };

  private generateSuggestions(extractedFacts: ExtractedFactsBackend): string[] {
    const suggestions: string[] = [];

    if (extractedFacts.facts.length === 0) {
      suggestions.push('尝试描述一个具体场景，包括看到和听到的内容');
    }
    
    if (extractedFacts.missingInformation.includes('具体时间')) {
      suggestions.push('加入时间信息有助于理解事件的背景和发展');
    }
    
    if (extractedFacts.subjectiveStatements.length > 2) {
      suggestions.push('将"我觉得"转换为"我观察到"，会有新发现');
    }

    suggestions.push('继续收集事实，真相往往在细节中');
    
    return suggestions;
  }

  async analyzeImageForAbnormalities(imageBase64: string): Promise<string[]> {
    await this.delay(600);

    // 模拟图片分析，返回客观观察和异常点
    const observations = [
      "图片左上角有一个时钟显示3:47",
      "画面中有3个人物，其中2人面向镜头",
      "背景是办公室环境，可见白板和会议桌",
      "光线来自右侧窗户，产生明显阴影"
    ];
    
    const anomalies = [
      "时钟显示下午时间，但窗外光线像是清晨",
      "白板上的字迹被部分擦除，但仍可见痕迹",
      "一个人的影子方向与其他人不一致"
    ];
    
    // 随机返回一些观察和异常
    const result = [...observations];
    if (Math.random() > 0.5) {
      result.push(anomalies[Math.floor(Math.random() * anomalies.length)]);
    }
    
    return result;
  }

  async generateDynamicModelParameters(messages: any[]) {
    await this.delay(200);

    // 基于对话历史生成生物体模型参数
    const factCount = messages.reduce((sum, msg) => {
      const facts = this.extractFacts(msg.content || '').facts;
      return sum + facts.length;
    }, 0);

    const complexity = Math.min(0.2 + (factCount * 0.05), 1);
    const coherence = 0.7 + Math.random() * 0.2;
    const evolution = Math.min(0.3 + (messages.length * 0.05), 1);

    // 识别认知模式
    const patterns: string[] = [];
    const biasLevel = this.calculateBiasLevel(messages);
    const insightDepth = this.calculateInsightDepth(messages);
    
    if (biasLevel > 0.5) patterns.push('认知偏见模式');
    if (insightDepth > 0.5) patterns.push('事实积累模式');
    if (factCount / Math.max(messages.length, 1) > 2) patterns.push('具体化思维');
    if (messages.length > 5) patterns.push('持续探索模式');

    return {
      complexity,
      coherence,
      evolution,
      patterns
    };
  }

  private calculateBiasLevel(messages: any[]): number {
    let biasCount = 0;
    messages.forEach(msg => {
      if (this.detectBias(msg.content || '')) biasCount++;
    });
    return biasCount / Math.max(messages.length, 1);
  }

  private calculateInsightDepth(messages: any[]): number {
    const factTotal = messages.reduce((sum, msg) => {
      const facts = this.extractFacts(msg.content || '').facts;
      return sum + facts.length;
    }, 0);
    return Math.min(factTotal / 20, 1); // 假设20个事实能达到深度洞见
  }

  private truncate(text: string, maxLength: number): string {
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}